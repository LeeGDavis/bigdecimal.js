package io.couch.gwtapp.client;

import com.google.gwt.core.client.JavaScriptObject;
import org.timepedia.exporter.client.Export;
import org.timepedia.exporter.client.NoExport;
import org.timepedia.exporter.client.Exportable;
import org.timepedia.exporter.client.ExportPackage;

@ExportPackage("bigdecimal")
@Export
public class BigDecimal extends java.math.BigDecimal implements Exportable {
  // I think this constructor is needed for Javascript compatibility.
  public BigDecimal() {
    super("0");
  }

  @NoExport
  public BigDecimal(java.math.BigDecimal source) {
    super(source.toString());
  }

  // Use a class method to wrap the constructor.
  public static BigDecimal __init__(JsArgs args) {
    String sig = JsArgs.signature(args);
    java.math.BigDecimal obj;

    if(sig == "BigInteger")
      obj = new java.math.BigDecimal(args.getBigInteger(0));
    else if(sig == "BigInteger number")
      obj = new java.math.BigDecimal(args.getBigInteger(0), args.getInt(1));
    else if(sig == "BigInteger number MathContext")
      obj = new java.math.BigDecimal(args.getBigInteger(0), args.getInt(1), args.getMathContext(2));
    else if(sig == "BigInteger MathContext")
      obj = new java.math.BigDecimal(args.getBigInteger(0), args.getMathContext(1));
    else if(sig == "array")
      obj = new java.math.BigDecimal(args.getCharArray(0));
    else if(sig == "array number number")
      obj = new java.math.BigDecimal(args.getCharArray(0), args.getInt(1), args.getInt(2));
    else if(sig == "array number number MathContext")
      obj = new java.math.BigDecimal(args.getCharArray(0), args.getInt(1), args.getInt(2), args.getMathContext(3));
    else if(sig == "array MathContext")
      obj = new java.math.BigDecimal(args.getCharArray(0), args.getMathContext(1));
    else if(sig == "number")
      obj = new java.math.BigDecimal(args.getDouble(0));
    else if(sig == "number MathContext")
      obj = new java.math.BigDecimal(args.getDouble(0), args.getMathContext(1));
    else if(sig == "string")
      obj = new java.math.BigDecimal(args.getString(0));
    else if(sig == "string MathContext")
      obj = new java.math.BigDecimal(args.getString(0), args.getMathContext(1));
    else
      throw new RuntimeException("Unknown initialization signature: " + sig);

    return new BigDecimal(obj);
  }

  // TODO: These should probably be implemented with JsArgs.signature() now.
  <%= wrap :BigDecimal, :abs %>
  <%= wrap :BigDecimal, :add, :BigDecimal %>
  <%= wrap :byte, :byteValueExact %>
  <%= wrap :int, :compareTo, :BigDecimal %>
  <%= wrap :BigDecimal, :divideToIntegralValue, :BigDecimal %>
  <%= wrap :double, :doubleValue %>
  <%= wrap :boolean, :equals, :Object %>
  <%= wrap :float, :floatValue %>
  <%= wrap :int, :hashCode %>
  <%= wrap :int, :intValue %>
  <%= wrap :int, :intValueExact %>
  <%# XXX: longValue, longValueExact cannot be returned, should be implemented in Javascript %>
  <%= wrap :BigDecimal, :max, :BigDecimal %>
  <%= wrap :BigDecimal, :min, :BigDecimal %>
  <%= wrap :BigDecimal, :movePointLeft, :int %>
  <%= wrap :BigDecimal, :movePointRight, :int %>
  <%= wrap :BigDecimal, :multiply, :BigDecimal %>
  <%= wrap :BigDecimal, :negate %>
  <%= wrap :BigDecimal, :plus %>
  <%= wrap :BigDecimal, :pow, :int %>
  <%= wrap :int, :precision %>
  <%= wrap :BigDecimal, :remainder, :BigDecimal %>
  <%= wrap :int, :scale %>
  <%= wrap :BigDecimal, :scaleByPowerOfTen, :int %>
  <%= wrap :short, :shortValueExact %>
  <%= wrap :int, :signum %>
  <%= wrap :BigDecimal, :stripTrailingZeros %>
  <%= wrap :BigDecimal, :subtract, :BigDecimal %>
  <%# TODO: toBigInteger, unscaledValue %>
  <%= wrap :String, :toEngineeringString %>
  <%= wrap :String, :toPlainString %>
  <%= wrap :String, :toString %>
  <%= wrap :BigDecimal, :ulp %>

  public static final BigDecimal valueOf(double val) {
    return new BigDecimal(new java.math.BigDecimal(val));
  }

  <%#= wrap :BigDecimal, :setScale, :int %>
  public BigDecimal setScale(int newScale, InitParams opts) {
    java.math.BigDecimal result = (opts != null && opts.has("roundingMode"))
      ? super.setScale(newScale, opts.getInt("roundingMode"))
      : super.setScale(newScale);
    return new BigDecimal(result);
  }

  <%#= wrap :BigDecimal, :divide, :BigDecimal %>
  <%#= wrap :BigDecimal, :divide, :BigDecimal, :int %>
  public BigDecimal divide(BigDecimal x, InitParams opts) {
    java.math.BigDecimal result;

    if(opts == null)
      result = super.divide(x);
    else {
      if(!opts.has("roundingMode"))
        result = super.divide(x);
      else if(opts.has("scale"))
        result = super.divide(x, opts.getInt("scale"), opts.getInt("roundingMode"));
      else
        result = super.divide(x, opts.getInt("roundingMode"));
    }

    return new BigDecimal(result);
  }

  public void x(JavaScriptObject... arguments) {
    // Convert all the arguments to a JS Array.
    log("Starting");
    JsArgs args = JsArgs.Fresh();
    //for(JavaScriptObject a : arguments) {
    //for(int a = 0; a < arguments.length; a++) {
      log(" will push");
      //args.push(a);
    //}
    //args.push(args, arguments[0]);
    log("Finished pushing");
    logObj(args);
  }

  public static native void log(String x) /*-{
    require("sys").puts(x);
  }-*/;

  public static native void logObj(JavaScriptObject x) /*-{
    require("sys").puts("object: " + require("sys").inspect(x));
  }-*/;

  // Fields
  <% %w[ ROUND_CEILING ROUND_DOWN ROUND_FLOOR ROUND_HALF_DOWN ROUND_HALF_EVEN ROUND_HALF_UP ROUND_UNNECESSARY ROUND_UP ].each do |field| %>
    public static final int <%= field %> = java.math.BigDecimal.<%= field %>;
  <% end %>

  // TODO: Make these actual fields
  <% %w[ ONE TEN ZERO ].each do |field| %>
    public static final BigDecimal <%= field %>() { return new BigDecimal(java.math.BigDecimal.<%= field %>); }
  <% end %>
}
